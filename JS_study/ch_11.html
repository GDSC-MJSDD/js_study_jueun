11장 원시값과 객체의 비교
데이터 타입
- 원시 타입: 숫자, 문자열, 불리언, null, undefined, 심벌, 객체 타입, 불변, 실제값 저장 > 값에 의한 전달
- 객체 타입: 가변, 참조값 저장 > 참조에 의한 전달

< 원시값 >
1. 불변 // 재할당만 계속
- 원시값은 읽기 전용
- 불변이라 함은 재할당은 가능하나 값 자체는 바뀔 수 없음을 의미함(메모리 안의 값은 그대로 남고 변수는 다른 메모리를 가리키게 되는 것)
cf. 상수(const)는 재할당 불가능
- 이러한 특징은 값의 추적을 어렵게 함

2. 문자열
- 숫자는 8바이트 크기: 어떤 값이든 해당 메모리 크기만 사용
- 문자열: *원시타입. 한글자당 2바이트로 숫자와 달리 글자수가 늘어나는 만큼 요구 메모리 크기 증가
- 그러므로 문자열은 불변
- 다만 문자열은 원시 타입인 동시에 유사 배열 객체로 인덱스로 프로퍼티에 접근 가능, length프로퍼티 가짐
- 문자열은 불변이므로 var str='string' ; str[0] = 'S'; 해도 str의 값은 'string'그대로임

3. 값에 의한 전달
- 원시 타입은 변수에 참조가 아닌 값이 할당된다. 그러므로 val1 = val2 이후 val1의 값을 바꾸면 val1의 값만 변한다.

< 객체 >
- 프로퍼티 개수 제한 없음
- 동적 생성, 삭제 가능: 원시타입과 달리 메모리 사전 정의 불가

1. 가변
- 메모리 주소를 통해 원시 값에 접근 가능한 원시타입과 달리 메모리 주소를 통해 참조값(객체가 저장된 주소)에 접근 가능
- 객체의 프로퍼티는 변할 수 있다. 그러므로 참조값은 변하지 않고 참조가 가리키는 객체 내부의 프로퍼티가 변한다.
>> 여러 식별자가 하나의 객체를 참조할 수 있다.
*얕은복사(객체의 참조값 복사)와 깊은복사(원시값처럼 완전한 복사본 만듦)
** 얕은복사, 깊은복사는 추후 다시 볼 것

2. 참조에 의한 전달
- obj1 = obj2; 하면 이때 값이 복사되고 다른 메모리를 가리키는 원시타입과 달리 참조를 복사하여 두 식별자는 같은 객체를 가리키게 된다.

===를 사용할 때, 객체를 할당한 변수를 비교하면 참조값을 비교하고, 원시값을 할당한 변수를 비교하면 원시값을 비교한다.
var obj1 = { name:'Lee' };
var obj2 = { name:'Lee' };
obj1 === obj2 // false
ibj1.name === obj2.name // true
