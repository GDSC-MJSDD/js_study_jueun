## ch14 전역 변수의 문제점
#### 변수의 생명 주기
전역 변수를 무분별하게 사용하지 말자~ 이유는 다음과 같다.

1. 지역 변수의 생명 주기

변수는 생명주기를 가졌다. 생명주기가 없다면 한번 선언한 변수가 프로그램 종료시까지 메모리 공간을 차지하게 된다.
* 지역 변수의 생명 주기
  - 지역 변수 선언은 함수 호출과 직후 자바스크립트 엔진에 의해 가장 먼저 실행된다.
  - 함수가 종료하면 지역변수는 소멸된다.
  - 즉, 함수와 동일

* 지역 변수가 함수보다 오래 생존하는 경우
  - 누군가 메모리 공간을 참조하고 있을 경우
  - 스코프의 경우에도 누군가 참조하고 있을 경우 그동안 소멸하지 않음

*호이스팅: 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징*
```javascript
var x = 'global';

function foo() {
  console.log(x);
  var x = 'local';
  }
  
foo();
```
이때 x는 지역변수가 선언되기 전이므로 전역변수를 참조해야 할 것 같지만, 호이스팅 때문에
undefined가 된다.

2. 전역 변수의 생명 주기

* 전역 변수의 생명 주기
  - 전역 객체의 프로퍼티가 되므로 전역 객체의 생명주기와 일치한다. (브라우저에서 전역객체는 window > 웹페이지 닫기 전까지 유효)
  - 21장 전역객체 vs 표준빌트인 참고

#### 전역 변수의 문제점

* 암묵적 결합: 전역변수를 모든 코드가 참조하고 변경할 수 있음

  - 코드 가독성 저하, 의도치 않은 상태 변경 위험

* 긴 생명주기

  - 상태 변경 가능 시간 길고 기회 많음 > 상태 변경에 따른 오류 발생 가능
  - var키워드로 선언된 변수 : 중복선언 허용 - 의도치 않은 재할당

* 스코프 체인 상에서 종점에 존재

  - 검색속도가 가장 느림

* 네임스페이스 오염

  - 파일이 분리되어 있어도 하나의 전역 스코프를 공유하므로 문제 발생 가능



#### 전역 변수의 사용을 억제하는 방법

* 전역변수는 반드시 사용해야 할 이유 없으면 사용하지 말것
* 변수 스코프는 좁을수록 좋다


1. 즉시 실행 함수

* 코드를 즉시 실행 함수로 감싸는 것. 그러면 변수는 즉시 실행 함수의 지역변수가 된다.


2. 네임스페이스 객체

* 전역에 네임스페이스 역할 할 객체 생성 후 전역변수처럼 쓰고싶은 변수를 프로퍼티처럼 추가

```javascript
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
  name : 'Lee',
  address : 'Seoul'
};

console.log(MYAPP.person.name)
```
위의 방법은 식별자 충돌을 방지할 수 있으나 네임스페이스 객체 자체가 전역변수에 할당


3. 모듈 패턴

* 클래스를 모방. 관련있는 변수와 함수를 모아 즉시실행함수로 감싼다.
* 전역변수 억제, 캡슐화 구현
* 클로저(24장) 기반
* *javascrip는 접근 제한자를 제공하지 않는다.*

```javascript
var Counter = ( function() {
  // private 변수
  var num = 0;
  
  // 외부로 공개할 데이터나 메서드 프로퍼티로 추가한 객체 반환
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
```


4. ES6 모듈

* ES6 모듈 사용 시 전역변수 사용 불가. ***파일 자체의 독자적인 모듈 스코프 제공***
* var 키워드로 선언한 변수 : 전역변수 x, window 객체의 프로퍼티 x
* script 태그에 type="module" 어트리뷰트 추가 시 동작. 
* 확장자는 .mjs 
